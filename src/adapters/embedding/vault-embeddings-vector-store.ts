/**
 * VaultEmbeddingsVectorStore
 *
 * Read-only vector store that reads embedding data generated by Vault Embeddings plugin.
 * Note embedding creation/storage is handled by Vault Embeddings plugin,
 * this class only reads the data and performs similarity search.
 */

import { App, TFile, normalizePath } from 'obsidian';
import type {
  IVectorStore,
  EmbeddingVector,
  VectorSearchResult,
  VectorSearchOptions,
} from '../../core/domain';

/**
 * Vault Embeddings index.json structure (09_Embedded/index.json)
 */
interface VaultEmbeddingIndex {
  version: string;
  totalNotes: number;
  lastUpdated: string;
  model: string;
  dimensions: number;
  notes: {
    [noteId: string]: {
      path: string;
      contentHash: string;
      updatedAt: string;
    };
  };
}

/**
 * Vault Embeddings individual embedding file structure (09_Embedded/embeddings/<noteId>.json)
 */
interface SerializedNoteEmbedding {
  noteId: string;
  notePath: string;
  title: string;
  contentHash: string;
  vector: number[];
  model: string;
  provider: string;
  dimensions: number;
  createdAt: string;
  updatedAt: string;
}

const DEFAULT_LIMIT = 10;
const DEFAULT_THRESHOLD = 0.3;
const CACHE_TTL_MS = 60000; // 1 minute cache

export interface VaultEmbeddingsVectorStoreConfig {
  /** Vault Embeddings storage path (default: '09_Embedded') */
  storagePath?: string;
  /** Embeddings folder name (default: 'embeddings') */
  embeddingsFolder?: string;
}

export class VaultEmbeddingsVectorStore implements IVectorStore {
  private app: App;
  private config: Required<VaultEmbeddingsVectorStoreConfig>;
  private cache: Map<string, EmbeddingVector> = new Map();
  private indexCache: VaultEmbeddingIndex | null = null;
  private lastCacheUpdate = 0;
  private initialized = false;

  constructor(app: App, config?: VaultEmbeddingsVectorStoreConfig) {
    this.app = app;
    this.config = {
      storagePath: config?.storagePath ?? '09_Embedded',
      embeddingsFolder: config?.embeddingsFolder ?? 'embeddings',
    };
  }

  /**
   * Initialize - load cache
   */
  async initialize(): Promise<void> {
    if (this.initialized) return;

    try {
      await this.loadAllEmbeddings();
      this.initialized = true;
      console.log(`[VaultEmbeddingsVectorStore] Initialized with ${this.cache.size} embeddings`);
    } catch (error) {
      console.error('[VaultEmbeddingsVectorStore] Initialization failed:', error);
      // Continue with empty cache even if initialization fails
      this.initialized = true;
    }
  }

  /**
   * Check service availability
   */
  isAvailable(): boolean {
    return this.cache.size > 0;
  }

  /**
   * Get embedding statistics
   */
  async getStats(): Promise<{
    isAvailable: boolean;
    totalEmbeddings: number;
    model: string;
    provider: string;
  }> {
    await this.ensureCacheValid();

    return {
      isAvailable: this.isAvailable(),
      totalEmbeddings: this.cache.size,
      model: this.indexCache?.model ?? 'unknown',
      provider: 'vault-embeddings',
    };
  }

  /**
   * Get stored embedding dimensions from index
   */
  getStoredDimensions(): number | null {
    return this.indexCache?.dimensions ?? null;
  }

  /**
   * Force cache refresh
   */
  async refresh(): Promise<void> {
    this.cache.clear();
    this.indexCache = null;
    this.lastCacheUpdate = 0;
    await this.loadAllEmbeddings();
    console.log(`[VaultEmbeddingsVectorStore] Cache refreshed: ${this.cache.size} embeddings`);
  }

  // ============================================================================
  // IVectorStore Implementation
  // ============================================================================

  /**
   * Store embedding - No-op (handled by Vault Embeddings plugin)
   */
  store(_embedding: EmbeddingVector): void {
    console.info('[VaultEmbeddingsVectorStore] store() is no-op. Use Vault Embeddings plugin to manage embeddings.');
  }

  /**
   * Search for similar vectors (Cosine Similarity)
   */
  search(queryVector: number[], options?: VectorSearchOptions): VectorSearchResult[] {
    const limit = options?.limit ?? DEFAULT_LIMIT;
    const threshold = options?.threshold ?? DEFAULT_THRESHOLD;
    const excludeNoteIds = new Set(options?.excludeNoteIds ?? []);

    const results: VectorSearchResult[] = [];
    let dimensionWarningLogged = false;

    for (const [noteId, embedding] of this.cache) {
      if (excludeNoteIds.has(noteId)) {
        continue;
      }

      // Skip if dimensions don't match
      if (queryVector.length !== embedding.vector.length) {
        if (!dimensionWarningLogged) {
          console.warn(`[VaultEmbeddingsVectorStore] Dimension mismatch: query=${queryVector.length}d, stored=${embedding.vector.length}d. Ensure query embeddings use the same provider as Vault Embeddings.`);
          dimensionWarningLogged = true;
        }
        continue;
      }

      const similarity = this.cosineSimilarity(queryVector, embedding.vector);

      if (similarity >= threshold) {
        results.push({
          noteId,
          notePath: embedding.notePath,
          similarity,
        });
      }
    }

    return results
      .sort((a, b) => b.similarity - a.similarity)
      .slice(0, limit);
  }

  /**
   * Get list of stored note IDs
   */
  getStoredNoteIds(): string[] {
    return Array.from(this.cache.keys());
  }

  /**
   * Remove embedding - No-op
   */
  remove(_noteId: string): void {
    console.info('[VaultEmbeddingsVectorStore] remove() is no-op. Use Vault Embeddings plugin to manage embeddings.');
  }

  /**
   * Clear all - No-op
   */
  clear(): void {
    console.info('[VaultEmbeddingsVectorStore] clear() is no-op. Use Vault Embeddings plugin to manage embeddings.');
  }

  /**
   * Get number of stored vectors
   */
  size(): number {
    return this.cache.size;
  }

  /**
   * Check if embedding exists for a specific note
   */
  has(noteId: string): boolean {
    return this.cache.has(noteId);
  }

  // ============================================================================
  // Private Methods
  // ============================================================================

  /**
   * Validate cache and refresh if needed
   */
  private async ensureCacheValid(): Promise<void> {
    const now = Date.now();
    if (now - this.lastCacheUpdate > CACHE_TTL_MS) {
      await this.loadAllEmbeddings();
    }
  }

  /**
   * Load all embedding files
   * Uses adapter fallback to resolve index inconsistency issues during Git sync
   */
  private async loadAllEmbeddings(): Promise<void> {
    // Index file path (use normalizePath for cross-platform compatibility)
    const indexPath = normalizePath(`${this.config.storagePath}/index.json`);

    try {
      // Load index.json (adapter fallback)
      let indexContent: string;
      const indexFile = this.app.vault.getAbstractFileByPath(indexPath);
      if (indexFile instanceof TFile) {
        indexContent = await this.app.vault.read(indexFile);
      } else {
        // Try direct adapter read if not in Obsidian index
        try {
          indexContent = await this.app.vault.adapter.read(indexPath);
          console.log(`[VaultEmbeddingsVectorStore] Used adapter.read for index`);
        } catch {
          console.warn(`[VaultEmbeddingsVectorStore] Index not found: ${indexPath}`);
          return;
        }
      }

      this.indexCache = JSON.parse(indexContent) as VaultEmbeddingIndex;

      // Embeddings folder path
      const embeddingsPath = normalizePath(`${this.config.storagePath}/${this.config.embeddingsFolder}`);

      // Load embedding files for each note in the index
      this.cache.clear();
      for (const noteId of Object.keys(this.indexCache.notes)) {
        // Convert noteId to safe filename (same method as Vault Embeddings)
        const safeId = noteId.replace(/[^a-zA-Z0-9-_]/g, '_');
        const embeddingFilePath = normalizePath(`${embeddingsPath}/${safeId}.json`);

        await this.loadEmbeddingFile(embeddingFilePath, noteId);
      }

      this.lastCacheUpdate = Date.now();
      console.log(`[VaultEmbeddingsVectorStore] Loaded ${this.cache.size} embeddings from Vault Embeddings`);
    } catch (error) {
      console.error('[VaultEmbeddingsVectorStore] Failed to load embeddings:', error);
    }
  }

  /**
   * Load individual embedding file (with adapter fallback support)
   */
  private async loadEmbeddingFile(filePath: string, noteId: string): Promise<void> {
    try {
      let content: string;
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof TFile) {
        content = await this.app.vault.read(file);
      } else {
        // Try direct adapter read
        try {
          content = await this.app.vault.adapter.read(filePath);
        } catch {
          return; // File not found - skip
        }
      }

      const data = JSON.parse(content) as SerializedNoteEmbedding;

      this.cache.set(noteId, {
        noteId: data.noteId,
        notePath: data.notePath,
        vector: data.vector,
        content: '', // Vault Embeddings doesn't store original content
      });
    } catch (error) {
      // Only warn for individual file load failures
      console.warn(`[VaultEmbeddingsVectorStore] Failed to load: ${filePath}`);
    }
  }

  /**
   * Calculate Cosine Similarity
   */
  private cosineSimilarity(a: number[], b: number[]): number {
    if (a.length !== b.length) {
      return 0;
    }

    let dotProduct = 0;
    let normA = 0;
    let normB = 0;

    for (let i = 0; i < a.length; i++) {
      dotProduct += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }

    const magnitude = Math.sqrt(normA) * Math.sqrt(normB);
    if (magnitude === 0) {
      return 0;
    }

    return dotProduct / magnitude;
  }
}
